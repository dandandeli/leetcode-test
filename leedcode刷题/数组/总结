1.对于同一个数组操作  可以用两个指针来操作  一个慢指针 一个快指针 快指针进行循环
2.对于两个数组间的操作，可以用两个指针分别指向两个数组比较操作
3.针对输入，先考虑和判断特殊情况
4.对于数组操作  可以优先排序后 在进行
5.动态数组不能用直接赋值来添加  需要用push_back()来动态添加
6.对下标自加自减操作时，要随时注意防止数组溢出
7.要再for循环外再加一个return
8.可以用a[i]是否等于0  来标记数字i是否出现
已知循环次数用for循环  未知循环次数只知道边界条件 用while循环
Eroor:357错误，表明代码里出现中文字符
当某vector对象为空容器时，不能对其进行拷贝、赋值、访问以及一些相关的写操作（如fill_n,copy等函数）。
所谓容器为空，与其容量（即内存空间capacity，可存储元素的最大数量）无关，只跟其大小（size，已经存储的元素数量）有关。

动态分配一个长度不定的数组
int n;
	cin>>n;
	int *p=new int[n];   
  
  vector<int> a(n);  这两种n都可以是变量 int a[n]是错误的；
  在栈上创建数组时，不能使用含有变量的表达式，如：int a[x+2];错误
原因：在栈上创建数组时编译器编译的时候就需要在栈上分配内存，可是有了变量以后，编译器就无法知道该分配多大的内存空间，故编译器会报错。
但是定义一般变量如：int a；编译器会自动识别 int 占多大内存分配给他。
对比：如果是动态创建数组时（也就是在堆上创建数组时）可以出现变量如：new a [x+1]；正确；
原因：在堆上创建数组时，编译器不会在编译的时候为它分配内存，而是在程序运行的时候为它分配内存，
我们可以知道，程序运行时变量的值就会明确是多少，故动态创建数组时可以出现变量；
堆里的是动态数组，是程序运行过程中动态加载的，而栈不一样，申请数组必须要是确定大小的的数字，在编译时就要确定下来，如果你const int x=7就不会报错
