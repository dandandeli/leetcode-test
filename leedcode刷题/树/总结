int* p;到底有没有在堆空间开辟一个4字节大小的内存空间呢？
没有，这是在栈内定义的一个指针，所以是在栈内开辟了一个4字节大小的内存空间（用来放指针变量p了），
与此对应的，int* p = new int;是在栈上开辟了4个字节放指针，又在堆上开辟了4个字节（准备）放p指向的int变量
下面那个问题跟上面这个问题其实没关系，不要把他们联系在一起
之所以会调用成功，是因为利用指针调用类的成员函数时，只跟指针的类型有关，而与其所指内容无关，
也就是说只要指针类型是这个类的指针，那就可以用它来调用这个类的成员函数。
如果这个函数做的事情根类对象无关，就像你只返回一个常数，那这个函数看起来是正常运行的，但如果在类里访问了类的成员变量（比如返回x），那就会出错，
因为此时要根据指针所指的内容去访问对应的成员变量，而指针实际上没有指向正确的地方，所以会出现内存访问错误


指针是系统的最大类型，32位就是32bit位，4byte字节；64位系统为64bit，8byte
被指针指向的变量数据必须是地址，必须初始化
被指针指向的变量类型必须与保存的数据类型一致
指针本身是匿名变量也有自己的内存地址

 TreeNode *head=new TreeNode(0);
 head->val=nums[0];//访问指针所指向的内容时 要先用new在堆上分配一个内存空间 否则会出现指针越界
 head=root;//如果只是对指针本身进行赋值，不需要访问其指向的内存 就不需要new了
 
 树的深度是从根节点开始(其深度为1)自顶向下逐层累加的，而高度是从叶节点开始(其高度为1)自底向上逐层累加的。
 虽然树的深度和高度一样，但是具体到树的某个节点，其深度和高度是不一样的。
 我的理解是:非根非叶结点的深度是从根节点数到它的，高度是从叶节点数到它的。

